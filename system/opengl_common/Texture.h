#pragma once

//Use special naming for PS3 to support managing the texture entirely in video memory.
#ifdef __CELLOS_LV2__
#define BUFFER_TARGET_ES	GL_TEXTURE_REFERENCE_BUFFER_SCE
#define glTexImageES(w,h)	glTextureReferenceSCE(GL_TEXTURE_2D, 1, (w), (h), 1, GL_ARGB_SCE, (w) * 4, (GLintptr)0);
#else
#define BUFFER_TARGET_ES	GL_PIXEL_UNPACK_BUFFER_ARB
#define glTexImageES(w,h)	glTexImage2D(GL_TEXTURE_2D, 0, 4, (w), (h), 0, GL_BGRA, GL_UNSIGNED_BYTE, (void*)0);
#endif

///Class managing an OpenGL texture.
class								Texture
{
	public:
		///Create a new Texture object.
		///@param aWidth Width of the texture, in pixels.
		///@param aHeight Height of the Texture, in pixels.
		inline						Texture					(uint32_t aWidth, uint32_t aHeight);

		///Destroy a Texture object.
		inline						~Texture				();
		
		///Fill the Texture with a solid color.
		///@param aColor RGBA Color used to fill the texture.
		inline void					Clear					(uint32_t aColor);

		///Map the Texture's pixel buffer into memory.
		///@return A pointer to the Texture's memory.
		inline uint32_t*			Map						();

		///Unmap the Texture from memory. Must be called an equal amount of times as Map to fully unmap the Texture.
		inline void					Unmap					();
	
		///Get the width of the Texture.
		///@return The width of the Texture, in pixels.
		uint32_t					GetWidth				() const {return Width;};

		///Get the height of the Texture.
		///@return The height of the Texture, in pixels.
		uint32_t					GetHeight				() const {return Height;};

		///Get the pitch of the Texture.
		///@return The height of the Texture, in pixels not bytes.
		uint32_t					GetPitch				() const {return Pitch;};

		///Enable or disable bi-linear filtering for the Texture.
		///@param aOn New state of the Texture filter.
		void						SetFilter				(bool aOn) {Filter = aOn;}

		///Ununsed
		///@return 0
		uint32_t					GetFlags				() const {return 0;};

		///Get the shift for the Red component of a texel.
		///@param The shift for the Red component of a texel.
		uint32_t					GetRedShift				() const {return 16;};

		///Get the shift for the Green component of a texel.
		///@param The shift for the Green component of a texel.
		uint32_t					GetGreenShift			() const {return 8;};

		///Get the shift for the Blue component of a texel.
		///@param The shift for the Blue component of a texel.
		uint32_t					GetBlueShift			() const {return 0;};

		///Get the shift for the Alpha component of a texel.
		///@param The shift for the Alpha component of a texel.
		uint32_t					GetAlphaShift			() const {return 24;};
		
		///Pack a set of values into a valid texel.
		///@param aRed The red component.
		///@param aGreen The green component.
		///@param aBlue The blue component.
		///@param aAlpha The alpha component.
		///@return A Texel.
		inline uint32_t				ConvertPixel			(uint8_t aRed, uint8_t aGreen, uint8_t aBlue, uint8_t aAlpha) const; //Below

	public: //Helper, do not call directly
		///Apply the Texture as the active OpenGL texture.
		inline void					Apply					();

		///Get the OpenGL texture ID for this Texture.
		///@return The ID of the texture, generated by glGenTextures.
		uint32_t					GetID					() const {return ID;}

	private:
		uint32_t					BufferID;				///The Texture's OpenGL pixel buffer ID.
		uint32_t					ID;						///The Texture's OpenGL texture ID.
		uint32_t					MapCount;				///The number of times the texture has been mapped.
		uint32_t*					Pixels;					///A pointer to the Texture's pixel data if mapped, null otherwise.

		uint32_t					Width;					///The width of the Texture in pixels.
		uint32_t					Height;					///The height of the Texture in pixels.
		uint32_t					Pitch;					///The pitch of the Texture in pixels.
		bool						Filter;					///Determine if the texture uses bi-linear filtering.
		bool						Valid;					///False if the texture needs its pixels re-uploaded when applied.
};

//Inlines
									Texture::Texture		(uint32_t aWidth, uint32_t aHeight) :
	BufferID(0),
	ID(0),
	MapCount(0),
	Pixels(0),
	Width(aWidth),
	Height(aHeight),
	Pitch(aWidth),
	Filter(false),
	Valid(false)
{
	//TODO: Add a sanity check

	glGenTextures(1, &ID);
	glGenBuffers(1, &BufferID);

	glBindBuffer(BUFFER_TARGET_ES, BufferID);
	glBufferData(BUFFER_TARGET_ES, aWidth * aHeight * 4, 0, GL_STATIC_DRAW);
}
						
									Texture::~Texture		()
{
	while(MapCount)
	{
		Unmap();
	}

	glDeleteTextures(1, &ID);
	glDeleteBuffers(1, &BufferID);
}

void								Texture::Clear			(uint32_t aColor)
{
	uint32_t* Pixels = Map();

	for(int i = 0; i != Width * Height; i ++)
	{
		Pixels[i] = aColor;
	}

	Unmap();
}	

uint32_t*							Texture::Map			()
{
	Valid = false;

	if(MapCount == 0)
	{
		glBindBuffer(BUFFER_TARGET_ES, BufferID);
		Pixels = (uint32_t*)glMapBuffer(BUFFER_TARGET_ES, GL_READ_WRITE);
		glBindBuffer(BUFFER_TARGET_ES, 0);
	}

	MapCount ++;
	return Pixels;
}

void								Texture::Unmap			()
{
	if(MapCount)
	{
		MapCount --;

		if(!MapCount)
		{
			glBindBuffer(BUFFER_TARGET_ES, BufferID);
			glUnmapBuffer(BUFFER_TARGET_ES);
			glBindBuffer(BUFFER_TARGET_ES, 0);
			Pixels = 0;
		}
	}
}

void								Texture::Apply			()
{
	glEnable(GL_TEXTURE_2D);
	glBindTexture(GL_TEXTURE_2D, ID);

	if(!Valid)
	{
		Valid = true;
		glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

		glBindBuffer(BUFFER_TARGET_ES, BufferID);
		glTexImageES(Width, Height);
		glBindBuffer(BUFFER_TARGET_ES, 0);
	}

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, Filter ? GL_LINEAR : GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, Filter ? GL_LINEAR : GL_NEAREST);	
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
}


uint32_t							Texture::ConvertPixel	(uint8_t aRed, uint8_t aGreen, uint8_t aBlue, uint8_t aAlpha) const
{
	return (aRed << GetRedShift()) | (aBlue << GetBlueShift()) | (aGreen << GetGreenShift()) | (aAlpha << GetAlphaShift());
}


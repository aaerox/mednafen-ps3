#RULES FOR COMPILE
%.so:
	@echo "[LD]  $(notdir $@)"
	@$(LD) -shared -Wl,-soname,$(TARGET).so.1 -o $@ $^

%.dll:
	@echo "[LD]  $(notdir $@)"
	@$(LD) -shared -o $@ $^

%.a:
	@echo "[AR]  $(notdir $@)"
	@$(AR) -rcs $(TARGET).a $^

%.elf:
	@echo "[LD]  $(notdir $@)"
	@$(LD) $^ $(LDFLAGS) $(LIBS) -o $@

%.exe:
	@echo "[LD]  $(notdir $@)"
	@$(LD) $^ $(LDFLAGS) $(LIBS) -o $@

################

#Build object list
CFILES		+= $(foreach dir,$(SOURCE),$(wildcard $(dir)/*.c))
HFILES		+= $(foreach dir,$(SOURCE),$(wildcard $(dir)/*.h))
CXXFILES	+= $(foreach dir,$(SOURCE),$(wildcard $(dir)/*.cpp))
SFILES		+= $(foreach dir,$(SOURCE),$(wildcard $(dir)/*.S))
OFILES		+= $(CFILES:.c=.o) $(CXXFILES:.cpp=.o) $(SFILES:.S=.o) 

#Final flags
CFLAGS		+= $(DEPSOPTIONS)
CXXFLAGS	+= $(DEPSOPTIONS)
ASFLAGS		+= $(DEPSOPTIONS)
CPPFLAGS	+= $(foreach dir,$(INCLUDE),-I$(CURDIR)/$(dir))
LDFLAGS		+= $(foreach dir,$(LIBDIRS),-L$(CURDIR)/$(dir))

#Determine smart pointer mode
ifeq ($(strip $(BOOST_PATH)),)
 ifeq ($(strip $(PLATFORM)),cell)
  $(error Set BOOST_PATH in environment)
 else
  $(warning Building as C++0x)
  CPPFLAGS += -DUSE_CPP0X_SMARTPTR -std=c++0x
 endif
else
 CPPFLAGS += -I$(BOOST_PATH)
endif

#Determine output file type
ifeq ($(strip $(TARGETPLATFORM)),windows)
 OUTTYPE				:=	exe
else
 #Probably shouldn't use the elf extension, but oh well
 OUTTYPE				:=	elf
endif

ifeq ($(strip $(TYPE)),lib)
 ifeq ($(strip $(PLATFORM)),dll)
  ifeq ($(strip $(TARGETPLATFORM)),windows)
   OUTTYPE				:=	dll
  else
   OUTTYPE				:=	so
  endif
 else
  OUTTYPE				:=	a
 endif
endif

#Rules
.PHONY: clean

$(TARGET).$(OUTTYPE): $(OFILES)

clean:
	@echo Clean...
	@rm -rf $(TARGET).$(OUTTYPE) $(OFILES) $(OFILES:.o=.d)

pch:
	$(CXX) $(CPPFLAGS) $(CXXFLAGS) -c pch.h -o pch.h.gch

-include $(OFILES:.o=.d)

